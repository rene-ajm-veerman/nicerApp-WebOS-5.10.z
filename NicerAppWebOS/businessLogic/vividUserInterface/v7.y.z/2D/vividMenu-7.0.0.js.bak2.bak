
class CascadingMenu {
  constructor(menuEl) {
      const menu = $('#siteMenu > ul > li > ul')[0];
      const openBtn = document.getElementById('btnShowStartMenu');
        clearTimeout(menu.timeout_onConstruct);
      menu.timeout_onConstruct = setTimeout (function(menu) {
            $(menu).addClass('has-submenu');
            $('li', menu).each(function(idx,el) {
                $(el).addClass('menu-item');
                if ($('ul',el).length>0) $(el).addClass('has-submenu');
            });
            $('ul', menu).addClass('submenu');
            $('ul',menu).addClass('submenu');
            $('.vividMenu_mainUL',menu).css({display:'block'});
            $(menu).css({
            top : $(window).height() - na.d.g.margin - 70 - $(menu).height(),
                        display : 'none'
            })

            // Toggle main menu
            openBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            menu.style.display = menu.style.display === 'none' ? 'inline-block' : 'none';
            $(menu).addClass('open').css ({
                top : $(window).height() - na.d.g.margin - 70 - $(menu).height(),
                left : 40,
                width : 'inherit',
                height : 'auto'
            });
            });

            // Close on outside click
            document.addEventListener('click', (e) => {
            if (!menu.contains(e.target) && e.target !== openBtn) {
                menu.style.display = 'none';
            }
            });

            // Smart positioning for all submenus

            const submenuItems = Array.from(document.querySelectorAll('#siteMenu li.menu-item'))
    .find(li => li.textContent.trim().startsWith('Site'))
    ?.querySelector('.submenu');    //$('ul.submenu',$(menu).parent().parent());

            submenuItems.each((idx,item) => {
                var submenu = item.querySelector('.submenu');
debugger;
                if (submenu) item.addEventListener('mouseenter', () => {
                    // Reset any previous adjustments
                    submenu.style.display = 'block';
                    submenu.style.left = '100%';
                    submenu.style.right = 'auto';
                    submenu.style.top = na.d.g.margin+'px';
                    submenu.style.bottom = 'auto';
                    debugger;

                    // Force reflow so getBoundingClientRect uses default position
                    submenu.getBoundingClientRect();

                    const submenuRect = submenu.getBoundingClientRect();
                    const viewportWidth = window.innerWidth;
                    const viewportHeight = window.innerHeight;

                    // Check horizontal overflow (right edge)
                    if (submenuRect.right > viewportWidth) {
                        submenu.style.left = 'auto';
                        submenu.style.right = '100%';
                    }

                    // Re-check after possible horizontal flip
                    const newRect = submenu.getBoundingClientRect();

                    // Check vertical overflow (bottom edge)
                    if (newRect.bottom > viewportHeight) {
                        submenu.style.top = 'auto';
                        submenu.style.bottom = (na.d.g.margin + $(submenu).height()) +  'px';
                    }
                });

                // Optional: reset on mouseleave if you want strict per-hover calc
                // (not needed here as each hover recalculates independently)
            });

    }, 500, menuEl);
  }
}
