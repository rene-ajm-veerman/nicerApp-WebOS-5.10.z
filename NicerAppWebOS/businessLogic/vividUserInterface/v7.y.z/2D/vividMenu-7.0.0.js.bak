 
class CascadingMenu {
  constructor(menuEl) {
    this.menu = menuEl;
    this.openMenus = new Set();
    this.hoverTimeout = null;
    this.delay = 150; // ms - prevents flicker on quick mouse moves

    $(menuEl).addClass('has-submenu');
    $('li', menuEl).each(function(idx,el) {
      $(el).addClass('menu-item');
      if ($('ul',el).length>0) $(el).addClass('has-submenu');
    });
    $('ul', menuEl).addClass('submenu');
    $('#'+menuEl.id+' > ul').removeClass('submenu').addClass('menu-root');
    /*
    setTimeout (() => {
      $('ul', menuEl).not('.vividMenu_mainUL').remove();
    }, 2500);
    */
    $('.vividMenu_layout, .vividMenu_segments', menuEl).remove();
    $('.vividMenu_mainUL').css({display:'block'});

    this.init();

  }

  init() {
    // Hover open/close with delay
    $(this.menu).css({
      top : $(window).height() - na.d.g.margin - 70 - $(this.menu).height(),
      left : 40,
      width : 200,
      height: 50
    });


    this.menu.addEventListener('mouseenter', (e) => {
      const item = e.target.closest('.has-submenu');
      if (!item) return;
      clearTimeout(this.hoverTimeout);
      this.hoverTimeout = setTimeout((item) => this.open(item), this.delay,item);
    }, true);

    this.menu.addEventListener('mouseleave', (e) => {
      const item = e.target.closest('.has-submenu');
      if (!item) return;
      clearTimeout(this.hoverTimeout);
      this.hoverTimeout = setTimeout(() => this.close(item), this.delay);
    }, true);

    // Click to toggle (good for touch/mobile)
    this.menu.addEventListener('click', (e) => {
      const item = e.target.closest('.has-submenu > a');
      if (!item) return;
      e.preventDefault();
      e.stopPropagation();
      const li = item.parentElement;
      if (this.openMenus.has(li)) {
        this.close(li);
      } else {
        this.open(li);
      }
    });

    // Close all on outside click
    document.addEventListener('click', (e) => {
      if (!this.menu.contains(e.target)) {
        this.closeAll();
      }
    });

    // Keyboard support (basic)
    this.menu.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') this.closeAll();
    });
  }

  open(li) {
    this.closeSiblings(li);
    li.classList.add('open');
    this.openMenus.add(li);
    debugger;
    this.positionSubmenu(li.querySelector('.submenu'));
  }

  close(li) {
    li.classList.remove('open');
    this.openMenus.delete(li);
  }

  closeAll() {
    this.openMenus.forEach(li => li.classList.remove('open'));
    this.openMenus.clear();
  }

  closeSiblings(li) {
    const siblings = li.parentElement.children;
    for (let sibling of siblings) {
      if (sibling !== li) this.close(sibling);
    }
  }

  positionSubmenu(submenu) {
    const rect = submenu.getBoundingClientRect();
    const parentRect = submenu.parentElement.getBoundingClientRect();

    // Flip left if overflowing right
    if (rect.right > window.innerWidth) {
      submenu.style.left = 'auto';
      submenu.style.right = '100%';
      submenu.classList.add('right-overflow');
    } else {
      submenu.style.left = '100%';
      submenu.style.right = 'auto';
      submenu.classList.remove('right-overflow');
    }

    // Flip up if overflowing bottom (optional)
    if (rect.bottom > window.innerHeight) {
      submenu.style.top = 'auto';
      submenu.style.bottom = '100%';
    }
  }
}
