<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Upgraded 3D Park: Realistic Water, Curved Lake Path, GLB Models</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #info {
            position: absolute; top: 10px; left: 10px; color: white;
            background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px;
            font-family: Arial, sans-serif; font-size: 14px;
        }
        #loading { position: absolute; top: 50%; left: 50%; color: white; font-size: 18px; }
    </style>
    <!--
<script type="importmap">
  {
    "imports": {
        "THREE" : "https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js",
        "OrbitControls" : "https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js",
        "GLTFLoader" : "https://cdn.jsdelivr.net/npm/three@0.132.2/examples/jsm/loaders/GLTFLoader.min.js",
        "RGBELoader" : "https://cdn.jsdelivr.net/npm/three@0.132.2/examples/jsm/loaders/RGBELoader.min.js"
    }
  }
</script>
-->
<script type="module">
/*
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js";
    import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js";
    import { GLTFLoader } from "https://cdn.jsdelivr.net/npm/three@0.132.2/examples/jsm/loaders/GLTFLoader.min.js";
    import { RGBELoader } from "https://cdn.jsdelivr.net/npm/three@0.132.2/examples/jsm/loaders/RGBELoader.min.js";
*/

import * as three from 'https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js';
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js';
import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/controls/OrbitControls.js';
import { GLTFLoader } from "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/loaders/GLTFLoader.min.js";
import { RGBELoader } from "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/loaders/RGBELoader.min.js";


</script>
</head>

<body>
    <div id="info">Click-drag to look • Scroll to zoom • Right-drag to pan • Auto-orbit active</div>
    <div id="loading">Loading GLB models...</div>
    <!--
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script type="module" src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/jsm/loaders/GLTFLoader.min.js"></script>
    <script type="module" src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/jsm/loaders/RGBELoader.min.js"></script>
    -->
    <script type="module">
    window.onload = function() {
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);

        // Camera & Renderer
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1;
        document.body.appendChild(renderer.domElement);

        // OrbitControls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 10;
        controls.maxDistance = 50;
        controls.maxPolarAngle = Math.PI / 2.2;

        // Lighting
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        // Ground (lawn)
        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(100, 100),
            new THREE.MeshLambertMaterial({ color: 0x228B22 })
        );
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        // Irregular curved lake (no straight shores) - Custom BufferGeometry
        const lakePoints = [];
        const numLakePoints = 50;
        for (let i = 0; i < numLakePoints; i++) {
            const angle = (i / numLakePoints) * Math.PI * 2;
            const radius = 10 + Math.sin(angle * 3) * 3 + Math.cos(angle * 5) * 2; // Organic irregularity
            lakePoints.push(new THREE.Vector3(Math.cos(angle) * radius, 0, Math.sin(angle) * radius));
        }
        const lakeShape = new THREE.Shape();
        lakeShape.moveTo(lakePoints[0].x, lakePoints[0].z);
        for (let i = 1; i < lakePoints.length; i++) {
            lakeShape.lineTo(lakePoints[i].x, lakePoints[i].z);
        }
        lakeShape.closePath();
        const lakeGeometry = new THREE.ShapeGeometry(lakeShape);
        lakeGeometry.rotateX(-Math.PI / 2);

        // Realistic water with reflections (via env map)
        let envMap;
        const rgbeLoader = new THREE.RGBELoader();
        rgbeLoader.load('https://threejs.org/examples/textures/equirectangular/venice_sunset_1k.hdr', (texture) => {
            envMap = texture;
            envMap.mapping = THREE.EquirectangularReflectionMapping;
            scene.environment = envMap;
            document.getElementById('loading').style.display = 'none';
        });

        const waterMaterial = new THREE.MeshStandardMaterial({
            color: 0x1E90FF,
            metalness: 0.1,
            roughness: 0.05,
            envMap: envMap,
            transparent: true,
            opacity: 0.95
        });
        const lake = new THREE.Mesh(lakeGeometry, waterMaterial);
        lake.position.set(-20, 0.01, 0); // Offset to left
        scene.add(lake);

        // Animate water ripples (displacement)
        const timeUniform = { value: 0 };
        waterMaterial.userData = { time: timeUniform };
        waterMaterial.onBeforeCompile = (shader) => {
            shader.uniforms.time = timeUniform;
            shader.vertexShader = 'uniform float time;\n' + shader.vertexShader;
            shader.vertexShader = shader.vertexShader.replace(
                '#include <begin_vertex>',
                '#include <begin_vertex>\n vec3 transformed = vec3( position.x + sin(position.x * 5.0 + time * 2.0) * 0.1, position.y + cos(position.z * 3.0 + time * 1.5) * 0.05, position.z );'
            );
        };

        // Winding path along lake shore (for walking)
        const pathPoints = [];
        const numPathPoints = 100;
        for (let i = 0; i < numPathPoints; i++) {
            const t = i / numPathPoints;
            const baseX = -25 + Math.sin(t * Math.PI * 2 * 1.5) * 8;
            const baseZ = Math.cos(t * Math.PI * 2 * 1.5) * 8;
            const noise = Math.sin(t * 10) * 1.5;
            pathPoints.push(new THREE.Vector3(baseX + noise, 0, baseZ + noise * 0.5));
        }
        const pathCurve = new THREE.CatmullRomCurve3(pathPoints, true); // Closed loop

        // GLTF Loader
        const loader = new THREE.GLTFLoader();
        let treeModel, walkingPersonModel, stageModel;

        // Load tree GLB (place tree.glb in same folder)
        loader.load('tree.glb', (gltf) => {
            treeModel = gltf.scene;
            treeModel.scale.set(0.5, 0.5, 0.5); // Adjust scale
            // Place multiple trees along shore
            for (let i = 0; i < 6; i++) {
                const clone = treeModel.clone();
                const pos = pathPoints[i * numPathPoints / 6];
                clone.position.set(pos.x, 0, pos.z);
                scene.add(clone);
            }
        }, undefined, (err) => console.error('Tree load error:', err)); // Fallback to primitives if missing

        // Load walking person GLB (place walking_person.glb in same folder)
        loader.load('walking_person.glb', (gltf) => {
            walkingPersonModel = gltf.scene;
            walkingPersonModel.scale.set(0.8, 0.8, 0.8);
        }, undefined, (err) => console.error('Person load error:', err));

        // Load stage GLB (place stage.glb in same folder)
        loader.load('stage.glb', (gltf) => {
            stageModel = gltf.scene;
            stageModel.position.set(20, 0, 0);
            stageModel.scale.set(2, 1, 2); // Adjust
            scene.add(stageModel);
        }, undefined, (err) => {
            // Fallback to primitive stage
            const fallbackStage = new THREE.Mesh(
                new THREE.BoxGeometry(10, 0.5, 15),
                new THREE.MeshLambertMaterial({ color: 0xA0522D })
            );
            fallbackStage.position.set(20, 0.25, 0);
            scene.add(fallbackStage);
        });

        // Enhanced primitive person creator (fallback for non-GLB)
        function createPrimitivePerson() {
            const person = new THREE.Group();
            // Torso, head, arms, legs, etc. (expanded from previous)
            const torso = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.4, 1.6, 12), new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff }));
            torso.position.y = 0.8;
            person.add(torso);

            const head = new THREE.Mesh(new THREE.SphereGeometry(0.28, 12, 12), new THREE.MeshLambertMaterial({ color: 0xFFDAB9 }));
            head.position.y = 1.8;
            person.add(head);

            // Arms (upper + lower)
            const armGeo = new THREE.CylinderGeometry(0.12, 0.12, 0.9, 8);
            const leftUpperArm = new THREE.Mesh(armGeo, new THREE.MeshLambertMaterial({ color: 0x4444ff }));
            leftUpperArm.position.set(-0.45, 1.2, 0);
            leftUpperArm.rotation.z = Math.PI / 4;
            person.add(leftUpperArm);

            const rightUpperArm = leftUpperArm.clone();
            rightUpperArm.position.x *= -1;
            rightUpperArm.rotation.z *= -1;
            person.add(rightUpperArm);

            const lowerArmGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8);
            const leftLowerArm = new THREE.Mesh(lowerArmGeo, leftUpperArm.material);
            leftLowerArm.position.set(0, -0.65, 0);
            leftUpperArm.add(leftLowerArm);

            const rightLowerArm = leftLowerArm.clone();
            rightUpperArm.add(rightLowerArm);

            // Hands
            const handGeo = new THREE.SphereGeometry(0.13, 8, 8);
            const leftHand = new THREE.Mesh(handGeo, new THREE.MeshLambertMaterial({ color: 0xFFDAB9 }));
            leftHand.position.y = -0.45;
            leftLowerArm.add(leftHand);

            const rightHand = leftHand.clone();
            rightLowerArm.add(rightHand);

            // Legs (upper + lower)
            const legGeo = new THREE.CylinderGeometry(0.15, 0.15, 1.2, 8);
            const leftUpperLeg = new THREE.Mesh(legGeo, new THREE.MeshLambertMaterial({ color: 0x222222 }));
            leftUpperLeg.position.set(-0.2, 0, 0);
            person.add(leftUpperLeg);

            const rightUpperLeg = leftUpperLeg.clone();
            rightUpperLeg.position.x *= -1;
            person.add(rightUpperLeg);

            const lowerLegGeo = new THREE.CylinderGeometry(0.12, 0.12, 1.1, 8);
            const leftLowerLeg = new THREE.Mesh(lowerLegGeo, leftUpperLeg.material);
            leftLowerLeg.position.set(0, -0.75, 0);
            leftUpperLeg.add(leftLowerLeg);

            const rightLowerLeg = leftLowerLeg.clone();
            rightUpperLeg.add(rightLowerLeg);

            // Feet
            const footGeo = new THREE.BoxGeometry(0.2, 0.08, 0.35);
            const leftFoot = new THREE.Mesh(footGeo, new THREE.MeshLambertMaterial({ color: 0x111111 }));
            leftFoot.position.set(0, -0.6, 0.08);
            leftLowerLeg.add(leftFoot);

            const rightFoot = leftFoot.clone();
            rightLowerLeg.add(rightFoot);

            person.joints = {
                leftUpperArm, rightUpperArm, leftLowerArm, rightLowerArm,
                leftUpperLeg, rightUpperLeg, leftLowerLeg, rightLowerLeg
            };
            return person;
        }

        // People arrays
        const primitivePeople = [];
        const walkingPeople = []; // For GLB walkers
        const behaviors = []; // 0=walk path, 1=idle, 2=sit

        // 15 walking people along curved lake path (prefer GLB)
        for (let i = 0; i < 15; i++) {
            let person;
            if (walkingPersonModel) {
                person = walkingPersonModel.clone();
                const mixer = new THREE.AnimationMixer(person);
                const action = mixer.clipAction(walkingPersonModel.animations[0]); // Assume walking clip
                action.play();
                person.userData.mixer = mixer;
            } else {
                person = createPrimitivePerson();
            }
            const t = (i / 15) * pathCurve.getLength();
            person.position.copy(pathCurve.getPointAt(t / pathCurve.getLength()));
            person.scale.set(0.8, 0.8, 0.8);
            scene.add(person);
            walkingPeople.push(person);
            behaviors.push(0); // Walk
        }

        // 15 remaining socializing (idle/sit, primitives)
        for (let i = 0; i < 15; i++) {
            const person = createPrimitivePerson();
            const groupX = (i % 5) * 2 - 4;
            const groupZ = Math.floor(i / 5) * 3 - 10;
            person.position.set(groupX, 0, groupZ);
            scene.add(person);
            primitivePeople.push(person);
            behaviors.push(Math.random() < 0.5 ? 1 : 2);
        }

        // 100 seated guests (primitives, sit)
        for (let row = 0; row < 10; row++) {
            for (let col = 0; col < 10; col++) {
                const person = createPrimitivePerson();
                person.scale.set(0.7, 0.7, 0.7);
                person.position.set(15 + col * 1.1, 0, -10 + row * 1.1);
                scene.add(person);
                primitivePeople.push(person);
                behaviors.push(2);
            }
        }

        // Speaker (primitive, idle)
        const speaker = createPrimitivePerson();
        speaker.scale.set(1.1, 1.1, 1.1);
        speaker.position.set(20, 1, 0); // On stage
        speaker.children[0].material = new THREE.MeshLambertMaterial({ color: 0xFF69B4 }); // Dress
        scene.add(speaker);
        primitivePeople.push(speaker);
        behaviors.push(1);

        // Animation functions (for primitives)
        function walkAnim(person, t) {
            const step = Math.sin(t * 5) * 0.6;
            const swing = Math.sin(t * 5) * 0.4;
            person.joints.leftUpperLeg.rotation.x = step;
            person.joints.rightUpperLeg.rotation.x = -step;
            person.joints.leftLowerLeg.rotation.x = Math.max(0, -step * 1.2);
            person.joints.rightLowerLeg.rotation.x = Math.max(0, step * 1.2);
            person.joints.leftUpperArm.rotation.z = Math.PI / 4 - swing;
            person.joints.rightUpperArm.rotation.z = -Math.PI / 4 + swing;
            person.children[1].position.y = 1.8 + Math.abs(step) * 0.02; // Head bob
        }

        function idleAnim(person, t) {
            const s = Math.sin(t * 2);
            person.joints.leftUpperArm.rotation.z = Math.PI / 4 + s * 0.15;
            person.joints.rightUpperArm.rotation.z = -Math.PI / 4 - s * 0.15;
            person.children[1].position.y = 1.8 + Math.abs(s) * 0.03;
        }

        function sitAnim(person, t) {
            person.position.y = 0.4;
            person.joints.leftUpperLeg.rotation.x = 1.2;
            person.joints.rightUpperLeg.rotation.x = 1.2;
            person.joints.leftLowerLeg.rotation.x = -2.0;
            person.joints.rightLowerLeg.rotation.x = -2.0;
            person.joints.leftUpperArm.rotation.z = 0.8;
            person.joints.rightUpperArm.rotation.z = -0.8;
            person.joints.leftLowerArm.rotation.x = -1.2;
            person.joints.rightLowerArm.rotation.x = -1.2;
        }

        // Camera circular path
        const orbitRadius = 25;
        const flyHeight = 2.5;
        const center = new THREE.Vector3(0, 0, 0);
        let angle = 0;
        function updateCamera() {
            camera.position.x = center.x + orbitRadius * Math.cos(angle);
            camera.position.y = center.y + flyHeight;
            camera.position.z = center.z + orbitRadius * Math.sin(angle);
            camera.lookAt(center);
            controls.target.copy(center);
        }
        updateCamera();

        // Animation loop
        const clock = new THREE.Clock();
        const mixers = []; // For GLB animations
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const elapsed = clock.elapsedTime;

            // Update water ripples
            timeUniform.value = elapsed;

            // Update camera orbit
            angle += 0.2 * delta;
            updateCamera();
            controls.update();

            // Update GLB mixers
            mixers.forEach(mixer => mixer.update(delta));

            // Animate walking people along path
            walkingPeople.forEach((person, i) => {
                const t = (elapsed * 0.5 + i * 0.1) % 1; // Speed along path
                const pos = pathCurve.getPointAt(t);
                person.position.copy(pos);
                const tangent = pathCurve.getTangentAt(t);
                person.lookAt(pos.clone().add(tangent)); // Face direction
                if (person.userData.mixer) {
                    // GLB handles walk anim
                } else {
                    walkAnim(person, elapsed + i);
                }
            });

            // Animate primitives
            [...primitivePeople].forEach((person, i) => {
                const idx = i + 15; // Offset for behaviors
                const beh = behaviors[idx];
                if (beh === 0) walkAnim(person, elapsed + i);
                else if (beh === 1) idleAnim(person, elapsed + i);
                else if (beh === 2) sitAnim(person, elapsed);
            });

            renderer.render(scene, camera);
        }
        animate();

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Init mixers after load
        setTimeout(() => {
            walkingPeople.forEach(p => { if (p.userData.mixer) mixers.push(p.userData.mixer); });
        }, 1000);
    };
    </script>
</body>
</html>
